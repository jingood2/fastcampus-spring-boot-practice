package com.fastcampus.fastcampusspringbootpractice.service;
// Generated by CodiumAI

import com.fastcampus.fastcampusspringbootpractice.constant.EventStatus;
import com.fastcampus.fastcampusspringbootpractice.dto.EventDTO;

import com.fastcampus.fastcampusspringbootpractice.repository.EventRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.then;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
public class EventServiceTest {

    @InjectMocks
    private EventService eventService;

    @Mock
    private EventRepository eventRepository;

    @DisplayName("검색 조건 이벤트 검색시, 전체 리스트 출력 리턴")
    @Test
    void test_giverNothing_whenSearchingEvents_thenReturnEntireEventList() {
        // Given
        given(eventRepository.findEvents(null, null, null, null, null))
                .willReturn(List.of(
                        EventDTO.of(1L, "오전 운동", EventStatus.OPENED, LocalDateTime.now().minusDays(1), LocalDateTime.now().plusDays(1),1,10, "memo", LocalDateTime.now(), LocalDateTime.now()),
                        EventDTO.of(2L, "오후 운동", EventStatus.CLOSED, LocalDateTime.now().minusDays(1), LocalDateTime.now().plusDays(1),1,10, "memo", LocalDateTime.now(), LocalDateTime.now())
                ));

        // When
        List<EventDTO> list = eventService.findEvents(null, null, null, null, null);

        // Then
        assertThat(list).hasSize(2);
        verify(eventRepository).findEvents(null, null, null, null, null);

    }

    @DisplayName("검색 조건과 함께 이벤트 검색하면 검색된 결과를 출력하여 보여준다")
    @Test
    void test_find_events_matching_criteria() {
        // Given
        Long placeId = 1L;
        String eventName = "오전 운동";
        EventStatus eventStatus = EventStatus.OPENED;
        LocalDateTime eventStartDatetime = LocalDateTime.now().minusDays(1);
        LocalDateTime eventEndDatetime = LocalDateTime.now().plusDays(1);

        given(eventRepository.findEvents(placeId, eventName, eventStatus, eventStartDatetime, eventEndDatetime))
                .willReturn(List.of(
                        EventDTO.of(1L, "오전 운동", eventStatus, eventStartDatetime, eventEndDatetime,1,10, "memo", LocalDateTime.now(), LocalDateTime.now())
                ));

        // When
        List<EventDTO>  events = eventService.findEvents(placeId, eventName, eventStatus, eventStartDatetime, eventEndDatetime);

        // Then
        assertThat(events)
            .hasSize(1)
            .allSatisfy(event -> {
                assertThat(event)
                        .hasFieldOrPropertyWithValue("placeId", placeId)
                        .hasFieldOrPropertyWithValue("eventName", eventName)
                        .hasFieldOrPropertyWithValue("eventStatus", eventStatus);
                assertThat(event.eventStartDatetime()).isAfterOrEqualTo(eventStartDatetime);
            });
        then(eventRepository).should().findEvents(placeId, eventName, eventStatus, eventStartDatetime, eventEndDatetime);
    }

    @DisplayName("조건이 없는 경우 빈 정보를 출력하여 보여준다")
    @Test
    void test_find_events_no_matching_criteria() {
        // Given
        Long eventId = 2L; // Assuming this ID does not exist
        given(eventRepository.findEventById(eventId)).willReturn(Optional.empty());

        // When
        Optional<EventDTO> result = eventService.findEventById(eventId);

        // Then
        assertThat(result).isEmpty();
        then(eventRepository).should().findEventById(eventId);
    }

    @DisplayName("findEventById should return an event when a valid ID is provided")
    @Test
    void test_find_event_by_id_valid_id() {
        // Given
        Long eventId = 1L;
        EventStatus eventStatus = EventStatus.OPENED;
        EventDTO eventDTO = EventDTO.of(eventId, "오전 운동", eventStatus,
                LocalDateTime.now().minusDays(10), LocalDateTime.now().minusDays(5),2,1,"memo", LocalDateTime.now(), LocalDateTime.now()  );
        given(eventRepository.findEventById(eventId)).willReturn(Optional.of(eventDTO));

        // When
        Optional<EventDTO> optionalEvent = eventService.findEventById(eventId);


        // Then
        assertThat(optionalEvent).hasValue(eventDTO);
        then(eventRepository).should().findEventById(eventId);
        // Assuming the repository is mocked and returns an event with the provided ID
        // assertTrue(optionalEvent.isPresent());
    }

    @DisplayName("createEvent should successfully create an event when valid data is provided")
    @Test
    void test_create_event_valid_data() {
        // Given
        EventDTO eventDTO = EventDTO.of(1L, "Sample Event", EventStatus.OPENED, LocalDateTime.now(), LocalDateTime.now().plusHours(2), 0, 100, "Sample memo", LocalDateTime.now(), LocalDateTime.now());
        given(eventRepository.createEvent(eventDTO)).willReturn(true);

        // When
        boolean result = eventService.createEvent(eventDTO);

        // Then
        assertThat(result).isTrue();
        verify(eventRepository).createEvent(eventDTO);

        // Assuming the repository is mocked and the event creation is successful
    }

    // updateEvent should successfully update an event when valid data is provided
    @DisplayName("eventId와 정보를 주면, 이벤트 정보를 변경하고 결과를 true로 반환한다")
    @Test
    void test_update_event_valid_data() {
        // Given
        Long eventId = 1L;
        EventDTO eventDTO = EventDTO.of(1L, "Updated Event", EventStatus.CLOSED, LocalDateTime.now(), LocalDateTime.now().plusHours(3), 0, 100, "Updated memo", LocalDateTime.now(), LocalDateTime.now());
        given(eventRepository.updateEvent(eventId, eventDTO)).willReturn(true);

        // When
        boolean result = eventService.updateEvent(eventId, eventDTO);

        // Then
        assertThat(result).isTrue();
        // Assuming the repository is mocked and the event update is successful
    }

    @DisplayName("Successfully deletes an event when a valid eventId is provided")
    @Test
    void test_delete_event_success() {
        // Given
        Long validEventId = 1L;
        EventDTO eventDTO = EventDTO.of(1L, "Sample Event", EventStatus.OPENED, LocalDateTime.now(), LocalDateTime.now().plusHours(2), 0, 100, "Sample memo", LocalDateTime.now(), LocalDateTime.now());
        given(eventRepository.createEvent(eventDTO)).willReturn(true);

        // When
        boolean result = eventService.deleteEvent(validEventId);

        // Then
        assertThat(result).isTrue();
    };

}